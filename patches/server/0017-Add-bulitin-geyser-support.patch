From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: skyouo0727 <anwugame@gmail.com>
Date: Thu, 25 Nov 2021 22:45:38 +0800
Subject: [PATCH] Add bulitin geyser support


diff --git a/build.gradle.kts b/build.gradle.kts
index 89a1bf9b7472bf9faa8c4da15a19391c8e17b487..f38305ecec845e1abc242497bc5a1ad005aace56 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -32,6 +32,10 @@ repositories {
         }
     }
     // Paper end
+
+    maven("https://repo.opencollab.dev/maven-snapshots/") // Brilliant - Geyser
+    maven("https://repo.opencollab.dev/maven-releases/") // Brilliant - Geyser
+    maven("https://repo.viaversion.com/") // Brilliant - Geyser
 }
 
 dependencies {
@@ -76,6 +80,15 @@ dependencies {
     implementation("com.github.technove:AIR:fe3dbb4420") // Airplane - config
     implementation("com.github.technove:Flare:fd8e0c3d7e") // Airplane - flare
 
+    implementation("com.github.oshi:oshi-core:5.8.3") // Brilliant - submit
+    implementation("org.geysermc:connector:1.4.3-SNAPSHOT") // Brilliant - geyser impl
+    implementation("org.geysermc.geyser.adapters:spigot-all:1.2-SNAPSHOT") // Brilliant - geyser impl
+    implementation("org.projectlombok:lombok:1.18.20") // Brilliant - geyser impl
+    implementation("com.viaversion:viaversion:4.0.0") // Brilliant - geyser impl
+    implementation("com.nukkitx:nbt:2.1.0") // Brilliant - geyser impl
+    implementation("org.cloudburstmc:math:1.1.0") // Brilliant - geyser impl
+    implementation("org.geysermc.floodgate:common:2.0-SNAPSHOT") // Brilliant - floodgate impl
+
     testImplementation("io.github.classgraph:classgraph:4.8.47") // Paper - mob goal test
     testImplementation("junit:junit:4.13.1")
     testImplementation("org.hamcrest:hamcrest-library:1.3")
@@ -92,7 +105,7 @@ tasks.jar {
         attributes(
             "Main-Class" to "org.bukkit.craftbukkit.Main",
             "Implementation-Title" to "CraftBukkit",
-            "Implementation-Version" to "git-Brilliant-$implementationVersion", // Brilliant // Airplane // Tuinity
+            "Implementation-Version" to "git-Brilliant-$implementationVersion", // Brilliant // Airplane // Tuinity // Brilliant
             "Implementation-Vendor" to SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'").format(Date()), // Paper
             "Specification-Title" to "Bukkit",
             "Specification-Version" to "1.17-R0.1-SNAPSHOT",
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 0427859eb3ed09f344e64d0cfc65b0e5fa579155..ecb182b203dc7661bbf00892c452cd2eefefb32f 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -55,11 +55,8 @@ import java.util.function.Function;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
 import javax.imageio.ImageIO;
-import net.minecraft.CrashReport;
-import net.minecraft.ReportedException;
-import net.minecraft.SharedConstants;
-import net.minecraft.SystemReport;
-import net.minecraft.Util;
+
+import net.minecraft.*;
 import net.minecraft.commands.CommandSource;
 import net.minecraft.commands.CommandSourceStack;
 import net.minecraft.commands.Commands;
@@ -186,7 +183,9 @@ import org.bukkit.event.server.ServerLoadEvent;
 
 import co.aikar.timings.MinecraftTimings; // Paper
 import org.spigotmc.SlackActivityAccountant; // Spigot
+import tech.skyouo.brilliant.Brilliant;
 import tech.skyouo.brilliant.BrilliantConfig;  // Brilliant
+import tech.skyouo.brilliant.geyser.Bootstrap;
 
 public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTask> implements SnooperPopulator, CommandSource, AutoCloseable {
     public static final int TPS = BrilliantConfig.config.getInt("tps-limit", 20);
@@ -1070,6 +1069,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             }
         }
 
+        if (BrilliantConfig.builtInGeyserInstanceEnable) Brilliant.stopGeyser();
+
         if (this.snooper.isStarted()) {
             this.snooper.interrupt();
         }
@@ -1201,6 +1202,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             long serverStartTime = Util.getNanos(); // Paper
             boolean dynamicTickControl = BrilliantConfig.config.getBoolean("dynamic-tps-control", true);
             if (this.initServer()) {
+                if (BrilliantConfig.builtInGeyserInstanceEnable) Brilliant.startGeyser();
+
                 double MSPT = MS_PER_TICK;
                 this.nextTickTime = Util.getMillis();
                 this.status.setDescription(new TextComponent(this.motd));
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index ea0da028f3e710c4d11cdf0b6abe2935f471ab47..5d3ff9133d1eeb040aa9ce807091a6afa9ccac15 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -71,6 +71,8 @@ import co.aikar.timings.MinecraftTimings; // Paper
 import org.bukkit.event.server.ServerCommandEvent;
 import org.bukkit.craftbukkit.util.Waitable;
 import org.bukkit.event.server.RemoteServerCommandEvent;
+import tech.skyouo.brilliant.BrilliantConfig;
+import tech.skyouo.brilliant.geyser.Bootstrap;
 // CraftBukkit end
 
 public class DedicatedServer extends MinecraftServer implements ServerInterface {
diff --git a/src/main/java/net/minecraft/server/network/ServerConnectionListener.java b/src/main/java/net/minecraft/server/network/ServerConnectionListener.java
index 961660f6f9e00b93252519e38b74c66c53388ed2..bb5663b8c32970ed92da1587c80f4aa84ed4bfad 100644
--- a/src/main/java/net/minecraft/server/network/ServerConnectionListener.java
+++ b/src/main/java/net/minecraft/server/network/ServerConnectionListener.java
@@ -221,6 +221,8 @@ public class ServerConnectionListener {
         }
     }
 
+    public List<ChannelFuture> getChannels() { return this.channels; } // Brilliant - Avoiding uses of reflect to get the channels
+
     public MinecraftServer getServer() {
         return this.server;
     }
diff --git a/src/main/java/tech/skyouo/brilliant/Brilliant.java b/src/main/java/tech/skyouo/brilliant/Brilliant.java
new file mode 100644
index 0000000000000000000000000000000000000000..08bbafcb9d2f1e3aa77429c23a5b09f85aff9ac1
--- /dev/null
+++ b/src/main/java/tech/skyouo/brilliant/Brilliant.java
@@ -0,0 +1,14 @@
+package tech.skyouo.brilliant;
+
+import tech.skyouo.brilliant.geyser.Bootstrap;
+
+public class Brilliant {
+    private static Bootstrap bootstrap = new Bootstrap();
+    public static void startGeyser() {
+        bootstrap.onEnable();
+    }
+
+    public static void stopGeyser() {
+        bootstrap.onDisable();
+    }
+}
diff --git a/src/main/java/tech/skyouo/brilliant/BrilliantConfig.java b/src/main/java/tech/skyouo/brilliant/BrilliantConfig.java
index 3096bddc5abe7391124e317228fe48c3d872ff5b..a8a02e110f7e43632079858b93b110bb9788e4ce 100644
--- a/src/main/java/tech/skyouo/brilliant/BrilliantConfig.java
+++ b/src/main/java/tech/skyouo/brilliant/BrilliantConfig.java
@@ -67,6 +67,7 @@ public class BrilliantConfig {
     public static void lateInit() {
         commands = new HashMap<>();
         commands.put("brilliant", new BrilliantCommand());
+        commands.put("submit", new SubmitCommand());
         registerCommands();
     }
 
@@ -160,7 +161,14 @@ public class BrilliantConfig {
     }
 
     public static int connectionTimeoutTick = 30;
-    public static void connectionTimeoutTick() { connectionTimeoutTick = getInt("connection-timeout-tick.value", 30); }
+    private static void connectionTimeoutTick() { connectionTimeoutTick = getInt("connection-timeout-tick.value", 30); }
 
     public static int aboveGroundTickCount = 4;
-    public static void aboveGroundTickCount() { aboveGroundTickCount = getInt("above-ground-tick-count.value", 4); }}
+    private static void aboveGroundTickCount() { aboveGroundTickCount = getInt("above-ground-tick-count.value", 4); }
+
+    public static boolean builtInGeyserInstanceEnable = false;
+    private static void builtInGeyserInstanceEnable() { builtInGeyserInstanceEnable = getBoolean("built-in-geyser.geyser.enable", false); }
+
+    public static boolean builtInFloodgateInstanceEnable = false;
+    private static void builtInFloodgateInstanceEnable() { builtInFloodgateInstanceEnable = getBoolean("built-in-geyser.floodgate.enable", false); }
+}
diff --git a/src/main/java/tech/skyouo/brilliant/floodgate/Floodgate.java b/src/main/java/tech/skyouo/brilliant/floodgate/Floodgate.java
new file mode 100644
index 0000000000000000000000000000000000000000..9d18a53c446d7a72b76c5c75964ee45c2d099468
--- /dev/null
+++ b/src/main/java/tech/skyouo/brilliant/floodgate/Floodgate.java
@@ -0,0 +1,2 @@
+package tech.skyouo.brilliant.floodgate;public class Floodgate {
+}
diff --git a/src/main/java/tech/skyouo/brilliant/floodgate/Platform.java b/src/main/java/tech/skyouo/brilliant/floodgate/Platform.java
new file mode 100644
index 0000000000000000000000000000000000000000..964700fb7cb04e5bae50b5b05f7efd64fdf91582
--- /dev/null
+++ b/src/main/java/tech/skyouo/brilliant/floodgate/Platform.java
@@ -0,0 +1,2 @@
+package tech.skyouo.brilliant.floodgate;public class Platform {
+}
diff --git a/src/main/java/tech/skyouo/brilliant/geyser/Bootstrap.java b/src/main/java/tech/skyouo/brilliant/geyser/Bootstrap.java
new file mode 100644
index 0000000000000000000000000000000000000000..32abddca2cf1bdfa8042d41d5eda63930c67e703
--- /dev/null
+++ b/src/main/java/tech/skyouo/brilliant/geyser/Bootstrap.java
@@ -0,0 +1,326 @@
+package tech.skyouo.brilliant.geyser;
+
+import com.github.steveice10.mc.protocol.MinecraftConstants;
+import com.viaversion.viaversion.api.Via;
+import com.viaversion.viaversion.api.data.MappingData;
+import com.viaversion.viaversion.api.protocol.ProtocolPathEntry;
+import com.viaversion.viaversion.api.protocol.version.ProtocolVersion;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandException;
+import org.geysermc.common.PlatformType;
+import org.geysermc.connector.GeyserConnector;
+import org.geysermc.connector.GeyserLogger;
+import org.geysermc.connector.bootstrap.GeyserBootstrap;
+import org.geysermc.connector.command.CommandManager;
+import org.geysermc.connector.common.AuthType;
+import org.geysermc.connector.configuration.GeyserConfiguration;
+import org.geysermc.connector.dump.BootstrapDumpInfo;
+import org.geysermc.connector.network.translators.world.WorldManager;
+import org.geysermc.connector.ping.GeyserLegacyPingPassthrough;
+import org.geysermc.connector.ping.IGeyserPingPassthrough;
+import org.geysermc.connector.utils.Constants;
+import org.geysermc.connector.utils.FileUtils;
+import org.geysermc.connector.utils.LanguageUtils;
+import org.geysermc.geyser.adapters.spigot.SpigotAdapters;
+import org.jetbrains.annotations.Nullable;
+import tech.skyouo.brilliant.BrilliantConfig;
+import tech.skyouo.brilliant.geyser.listener.BlockPlaceListener;
+import tech.skyouo.brilliant.geyser.listener.CraftingListener1_11;
+import tech.skyouo.brilliant.geyser.listener.PistonListener;
+import tech.skyouo.brilliant.geyser.world.*;
+import tech.skyouo.brilliant.geyser.world.dummy.FakePlugin;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.SocketAddress;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.List;
+import java.util.UUID;
+
+public class Bootstrap implements GeyserBootstrap {
+    private static String cwd = System.getProperty("user.dir");
+
+    private FakePlugin fakePlugin = new FakePlugin("BulitInGeyser");
+
+    private BaseWorldManager geyserWorldManager;
+    private Configuration geyserConfig;
+    private Logging geyserLogger;
+    private CommandManaging geyserCommandManager;
+    private Injector geyserInjector;
+
+    private IGeyserPingPassthrough geyserPingPassthrough;
+
+    private GeyserConnector geyserConnector;
+
+    private String minecraftVersion;
+
+    @Override
+    public void onEnable() {
+        try {
+            File targetFile = new File(Bootstrap.cwd, "geyser.yml");
+            File configFile = FileUtils.fileOrCopiedFromResource(targetFile, "config.yml", (x) -> x.replaceAll("generateduuid", UUID.randomUUID().toString()));
+            if (configFile.getName() == "config.yml") {
+                configFile.renameTo(targetFile);
+            }
+            this.geyserConfig = FileUtils.loadConfig(configFile, Configuration.class);
+
+            // By default this should be localhost but may need to be changed in some circumstances
+            if (this.geyserConfig.getRemote().getAddress().equalsIgnoreCase("auto")) {
+                geyserConfig.setAutoconfiguredRemote(true);
+                // Don't use localhost if not listening on all interfaces
+                if (!Bukkit.getIp().equals("0.0.0.0") && !Bukkit.getIp().equals("")) {
+                    geyserConfig.getRemote().setAddress(Bukkit.getIp());
+                }
+                geyserConfig.getRemote().setPort(Bukkit.getPort());
+            }
+
+            if (geyserConfig.getBedrock().isCloneRemotePort()) {
+                geyserConfig.getBedrock().setPort(Bukkit.getPort());
+            }
+
+            this.geyserLogger = new Logging(Bukkit.getLogger(), geyserConfig.isDebugMode());
+            GeyserConfiguration.checkGeyserConfiguration(geyserConfig, geyserLogger);
+
+            // Remove this in like a year
+            if (Bukkit.getPluginManager().getPlugin("floodgate-bukkit") != null) {
+                geyserLogger.severe(LanguageUtils.getLocaleStringLog("geyser.bootstrap.floodgate.outdated", Constants.FLOODGATE_DOWNLOAD_LOCATION));
+                this.onDisable();
+                return;
+            }
+
+            if (Bukkit.getPluginManager().getPlugin("geyser-spigot") != null || Bukkit.getPluginManager().getPlugin("floodgate-spigot") != null) {
+                geyserLogger.severe("You have geyser or floodgate installed on your Brilliant powered server, which isn't compatible with Brilliant yet.");
+                geyserLogger.severe("So the bulit-in geyser instance will be shutdown.");
+                this.onDisable();
+                return;
+            }
+
+            if (geyserConfig.isAutoconfiguredRemote() && BrilliantConfig.builtInFloodgateInstanceEnable) {
+                // Floodgate installed means that the user wants Floodgate authentication
+                geyserLogger.debug("Auto-setting to Floodgate authentication.");
+                geyserConfig.getRemote().setAuthType(AuthType.FLOODGATE);
+            }
+
+            geyserConfig.loadFloodgate(this);
+
+            this.minecraftVersion = Bukkit.getServer().getVersion().split("\\(MC: ")[1].split("\\)")[0];
+            this.geyserConnector = GeyserConnector.start(PlatformType.SPIGOT, this); // Brilliant - Yes, We masked ourselves as SPIGOT plugin.
+
+            if (geyserConfig.isLegacyPingPassthrough()) {
+                this.geyserPingPassthrough = GeyserLegacyPingPassthrough.init(geyserConnector);
+            } else {
+                this.geyserPingPassthrough = new PingPassthrough(geyserLogger);
+            }
+
+            this.geyserCommandManager = new CommandManaging(geyserConnector);
+
+            boolean isViaVersion = Bukkit.getPluginManager().getPlugin("ViaVersion") != null;
+            if (isViaVersion) {
+                try {
+                    // Ensure that we have the latest 4.0.0 changes and not an older ViaVersion version
+                    Class.forName("com.viaversion.viaversion.api.ViaManager");
+                } catch (ClassNotFoundException e) {
+                    geyserLogger.warning(LanguageUtils.getLocaleStringLog("geyser.bootstrap.viaversion.too_old",
+                            "https://ci.viaversion.com/job/ViaVersion/"));
+                    isViaVersion = false;
+                    if (this.geyserConfig.isDebugMode()) {
+                        e.printStackTrace();
+                    }
+                }
+            }
+
+            // Used to determine if Block.getBlockData() is present.
+            boolean isLegacy = !isCompatible(Bukkit.getServer().getVersion(), "1.13.0");
+            if (isLegacy)
+                geyserLogger.debug("Legacy version of Minecraft (1.12.2 or older) detected; falling back to ViaVersion for block state retrieval.");
+
+            boolean isPre1_12 = !isCompatible(Bukkit.getServer().getVersion(), "1.12.0");
+            // Set if we need to use a different method for getting a player's locale
+            CommandSending.setUseLegacyLocaleMethod(isPre1_12);
+
+            this.geyserInjector = new Injector(isViaVersion);
+            this.geyserInjector.initializeLocalChannel(this);
+
+            if (Boolean.parseBoolean(System.getProperty("Geyser.UseDirectAdapters", "true"))) {
+                try {
+                    String name = Bukkit.getServer().getClass().getPackage().getName();
+                    String nmsVersion = name.substring(name.lastIndexOf('.') + 1);
+                    SpigotAdapters.registerWorldAdapter(nmsVersion);
+                    if (isViaVersion && isViaVersionNeeded()) {
+                        if (isLegacy) {
+                            // Pre-1.13
+                            this.geyserWorldManager = new org.geysermc.platform.spigot.world.manager.NativeWorldManager1_12();
+                        } else {
+                            // Post-1.13
+                            this.geyserWorldManager = new LegacyNativeWorldManager(this.getServerProtocolVersion());
+                        }
+                    } else {
+                        // No ViaVersion
+                        this.geyserWorldManager = new NativeWorldManager();
+                    }
+                    geyserLogger.debug("Using NMS adapter: " + this.geyserWorldManager.getClass() + ", " + nmsVersion);
+                } catch (Exception e) {
+                    if (geyserConfig.isDebugMode()) {
+                        geyserLogger.debug("Error while attempting to find NMS adapter. Most likely, this can be safely ignored. :)");
+                        e.printStackTrace();
+                    }
+                }
+            } else {
+                geyserLogger.debug("Not using NMS adapter as it is disabled via system property.");
+            }
+            if (this.geyserWorldManager == null) {
+                // No NMS adapter
+                if (isLegacy && isViaVersion) {
+                    // Use ViaVersion for converting pre-1.13 block states
+                    this.geyserWorldManager = new WorldManager1_12();
+                } else if (isLegacy) {
+                    // Not sure how this happens - without ViaVersion, we don't know any block states, so just assume everything is air
+                    this.geyserWorldManager = new FallbackWorldManager();
+                } else {
+                    // Post-1.13
+                    this.geyserWorldManager = new BaseWorldManager();
+                }
+                geyserLogger.debug("Using default world manager: " + this.geyserWorldManager.getClass());
+            }
+            //Bukkit.getServer().getPluginManager().registerEvents(blockPlaceListener, fakePlugin); // Brilliant - Drop the listener since we couldn't get it work
+            //Bukkit.getServer().getPluginManager().registerEvents(new PistonListener(geyserConnector, this.geyserWorldManager), fakePlugin); // Brilliant - Drop the listener since we couldn't get it work
+
+            if (isPre1_12) {
+                // Register events needed to send all recipes to the client
+                Bukkit.getServer().getPluginManager().registerEvents(new CraftingListener1_11(geyserConnector), fakePlugin);
+            }
+
+            MinecraftServer.getServer().server.getCommandMap().register("geyser", "Brilliant", new CommandExecuteCommand(geyserConnector));
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    @Override
+    public void onDisable() {
+        if (geyserConnector != null) {
+            geyserConnector.shutdown();
+        }
+        if (geyserInjector != null) {
+            geyserInjector.shutdown();
+        }
+    }
+
+    @Override
+    public GeyserConfiguration getGeyserConfig() {
+        return this.geyserConfig;
+    }
+
+    @Override
+    public GeyserLogger getGeyserLogger() {
+        return this.geyserLogger;
+    }
+
+    @Override
+    public CommandManager getGeyserCommandManager() {
+        return this.geyserCommandManager;
+    }
+
+    @Override
+    public IGeyserPingPassthrough getGeyserPingPassthrough() {
+        return this.geyserPingPassthrough;
+    }
+
+    @Override
+    public WorldManager getWorldManager() {
+        return GeyserBootstrap.super.getWorldManager();
+    }
+
+    @Override
+    public Path getConfigFolder() {
+        return Paths.get(System.getProperty("user.dir"));
+    }
+
+    @Override
+    public BootstrapDumpInfo getDumpInfo() {
+        return null;
+    }
+
+    @Nullable
+    @Override
+    public String getMinecraftServerVersion() {
+        return GeyserBootstrap.super.getMinecraftServerVersion();
+    }
+
+    @Nullable
+    @Override
+    public SocketAddress getSocketAddress() {
+        return GeyserBootstrap.super.getSocketAddress();
+    }
+
+    @Override
+    public Path getLogsPath() {
+        return GeyserBootstrap.super.getLogsPath();
+    }
+
+    public boolean isCompatible(String version, String whichVersion) {
+        int[] currentVersion = parseVersion(version);
+        int[] otherVersion = parseVersion(whichVersion);
+        int length = Math.max(currentVersion.length, otherVersion.length);
+        for (int index = 0; index < length; index = index + 1) {
+            int self = (index < currentVersion.length) ? currentVersion[index] : 0;
+            int other = (index < otherVersion.length) ? otherVersion[index] : 0;
+
+            if (self != other) {
+                return (self - other) > 0;
+            }
+        }
+        return true;
+    }
+
+    private int[] parseVersion(String versionParam) {
+        versionParam = (versionParam == null) ? "" : versionParam;
+        if (versionParam.contains("(MC: ")) {
+            versionParam = versionParam.split("\\(MC: ")[1];
+            versionParam = versionParam.split("\\)")[0];
+        }
+        String[] stringArray = versionParam.split("[_.-]");
+        int[] temp = new int[stringArray.length];
+        for (int index = 0; index <= (stringArray.length - 1); index = index + 1) {
+            String t = stringArray[index].replaceAll("\\D", "");
+            try {
+                temp[index] = Integer.parseInt(t);
+            } catch (NumberFormatException ex) {
+                temp[index] = 0;
+            }
+        }
+        return temp;
+    }
+
+    /**
+     * @return the server version before ViaVersion finishes initializing
+     */
+    public ProtocolVersion getServerProtocolVersion() {
+        return ProtocolVersion.getClosest(this.minecraftVersion);
+    }
+
+    /**
+     * This function should not run unless ViaVersion is installed on the server.
+     *
+     * @return true if there is any block mappings difference between the server and client.
+     */
+    private boolean isViaVersionNeeded() {
+        ProtocolVersion serverVersion = getServerProtocolVersion();
+        List<ProtocolPathEntry> protocolList = Via.getManager().getProtocolManager().getProtocolPath(MinecraftConstants.PROTOCOL_VERSION,
+                serverVersion.getVersion());
+        if (protocolList == null) {
+            // No translation needed!
+            return false;
+        }
+        for (int i = protocolList.size() - 1; i >= 0; i--) {
+            MappingData mappingData = protocolList.get(i).getProtocol().getMappingData();
+            if (mappingData != null) {
+                return true;
+            }
+        }
+        // All mapping data is null, which means client and server block states are the same
+        return false;
+    }
+}
diff --git a/src/main/java/tech/skyouo/brilliant/geyser/CommandExecuteCommand.java b/src/main/java/tech/skyouo/brilliant/geyser/CommandExecuteCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..474a391913acb70fe75876a4e74c5e932855ec68
--- /dev/null
+++ b/src/main/java/tech/skyouo/brilliant/geyser/CommandExecuteCommand.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ * @author GeyserMC
+ * @link https://github.com/GeyserMC/Geyser
+ */
+
+package tech.skyouo.brilliant.geyser;
+
+import org.bukkit.ChatColor;
+import org.bukkit.Location;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.command.TabExecutor;
+import org.geysermc.connector.GeyserConnector;
+import org.geysermc.connector.command.CommandExecutor;
+import org.geysermc.connector.command.GeyserCommand;
+import org.geysermc.connector.network.session.GeyserSession;
+import org.geysermc.connector.utils.LanguageUtils;
+
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+class CommandExecute extends CommandExecutor implements TabExecutor {
+
+    public CommandExecute(GeyserConnector connector) {
+        super(connector);
+    }
+
+    @Override
+    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
+        CommandSending commandSender = new CommandSending(sender);
+        GeyserSession session = getGeyserSession(commandSender);
+
+        if (args.length > 0) {
+            GeyserCommand geyserCommand = getCommand(args[0]);
+            if (geyserCommand != null) {
+                if (!sender.hasPermission(geyserCommand.getPermission())) {
+                    String message = LanguageUtils.getPlayerLocaleString("geyser.bootstrap.command.permission_fail", commandSender.getLocale());
+
+                    commandSender.sendMessage(ChatColor.RED + message);
+                    return true;
+                }
+                if (geyserCommand.isBedrockOnly() && session == null) {
+                    sender.sendMessage(ChatColor.RED + LanguageUtils.getPlayerLocaleString("geyser.bootstrap.command.bedrock_only", commandSender.getLocale()));
+                    return true;
+                }
+                geyserCommand.execute(session, commandSender, args.length > 1 ? Arrays.copyOfRange(args, 1, args.length) : new String[0]);
+                return true;
+            }
+        } else {
+            getCommand("help").execute(session, commandSender, new String[0]);
+            return true;
+        }
+        return true;
+    }
+
+    @Override
+    public List<String> onTabComplete(CommandSender sender, Command command, String label, String[] args) {
+        if (args.length == 1) {
+            return tabComplete(new CommandSending(sender));
+        }
+        return Collections.emptyList();
+    }
+}
+
+public class CommandExecuteCommand extends Command {
+    CommandExecute commandExecuting;
+
+    public CommandExecuteCommand(GeyserConnector connector) {
+        super("geyser");
+        this.description = "The main command for Geyser.";
+        this.usageMessage = "/geyser <subcommand>";
+        this.setPermission("bukkit.command.brilliant");
+
+        commandExecuting = new CommandExecute(connector);
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args, Location location) throws IllegalArgumentException {
+        return commandExecuting.onTabComplete(sender, this, "", args);
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String commandLabel, String[] args) {
+        return  commandExecuting.onCommand(sender, this, commandLabel, args);
+    }
+}
+
diff --git a/src/main/java/tech/skyouo/brilliant/geyser/CommandManaging.java b/src/main/java/tech/skyouo/brilliant/geyser/CommandManaging.java
new file mode 100644
index 0000000000000000000000000000000000000000..8b17a1667ed4760e371bd6e31dd3a7df8f655f84
--- /dev/null
+++ b/src/main/java/tech/skyouo/brilliant/geyser/CommandManaging.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ * @author GeyserMC
+ * @link https://github.com/GeyserMC/Geyser
+ */
+
+package tech.skyouo.brilliant.geyser;
+
+import org.bukkit.Bukkit;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandMap;
+import org.geysermc.connector.GeyserConnector;
+import org.geysermc.connector.command.CommandManager;
+
+import java.lang.reflect.Field;
+
+public class CommandManaging extends CommandManager {
+
+    private static CommandMap COMMAND_MAP;
+
+    static {
+        try {
+            Field cmdMapField = Bukkit.getServer().getClass().getDeclaredField("commandMap");
+            cmdMapField.setAccessible(true);
+            COMMAND_MAP = (CommandMap) cmdMapField.get(Bukkit.getServer());
+        } catch (NoSuchFieldException | IllegalAccessException ex) {
+            ex.printStackTrace();
+        }
+    }
+
+    public CommandManaging(GeyserConnector connector) {
+        super(connector);
+    }
+
+    @Override
+    public String getDescription(String command) {
+        Command cmd = COMMAND_MAP.getCommand(command.replace("/", ""));
+        return cmd != null ? cmd.getDescription() : "";
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/tech/skyouo/brilliant/geyser/CommandSending.java b/src/main/java/tech/skyouo/brilliant/geyser/CommandSending.java
new file mode 100644
index 0000000000000000000000000000000000000000..348b09eacf58c1b9144930a358a323e41a152f6b
--- /dev/null
+++ b/src/main/java/tech/skyouo/brilliant/geyser/CommandSending.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ * @author GeyserMC
+ * @link https://github.com/GeyserMC/Geyser
+ */
+
+package tech.skyouo.brilliant.geyser;
+
+import org.bukkit.command.ConsoleCommandSender;
+import org.bukkit.entity.Player;
+import org.geysermc.connector.GeyserConnector;
+import org.geysermc.connector.command.CommandSender;
+import org.geysermc.connector.utils.LanguageUtils;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+public class CommandSending implements CommandSender {
+
+    /**
+     * Whether to use {@code Player.getLocale()} or {@code Player.spigot().getLocale()}, depending on version.
+     * 1.12 or greater should not use the legacy method.
+     */
+    private static boolean USE_LEGACY_METHOD = false;
+    private static Method LOCALE_METHOD;
+
+    private final org.bukkit.command.CommandSender handle;
+    private final String locale;
+
+    public CommandSending(org.bukkit.command.CommandSender handle) {
+        this.handle = handle;
+        this.locale = getSpigotLocale();
+        // Ensure even Java players' languages are loaded
+        LanguageUtils.loadGeyserLocale(locale);
+    }
+
+    @Override
+    public String getName() {
+        return handle.getName();
+    }
+
+    @Override
+    public void sendMessage(String message) {
+        handle.sendMessage(message);
+    }
+
+    @Override
+    public boolean isConsole() {
+        return handle instanceof ConsoleCommandSender;
+    }
+
+    @Override
+    public String getLocale() {
+        return locale;
+    }
+
+    @Override
+    public boolean hasPermission(String permission) {
+        return handle.hasPermission(permission);
+    }
+
+    /**
+     * Set if we are on pre-1.12, and therefore {@code player.getLocale()} doesn't exist and we have to get
+     * {@code player.spigot().getLocale()}.
+     *
+     * @param useLegacyMethod if we are running pre-1.12 and therefore need to use reflection to get the player locale
+     */
+    public static void setUseLegacyLocaleMethod(boolean useLegacyMethod) {
+        USE_LEGACY_METHOD = useLegacyMethod;
+        if (USE_LEGACY_METHOD) {
+            try {
+                //noinspection JavaReflectionMemberAccess - of course it doesn't exist; that's why we're doing it
+                LOCALE_METHOD = Player.Spigot.class.getMethod("getLocale");
+            } catch (NoSuchMethodException e) {
+                GeyserConnector.getInstance().getLogger().debug("Player.Spigot.getLocale() doesn't exist? Not a big deal but if you're seeing this please report it to the developers!");
+            }
+        }
+    }
+
+    /**
+     * So we only have to do nasty reflection stuff once per command
+     *
+     * @return the locale of the Spigot player
+     */
+    private String getSpigotLocale() {
+        if (handle instanceof Player player) {
+            if (USE_LEGACY_METHOD) {
+                try {
+                    // sigh
+                    // This was the only option on older Spigot instances and now it's gone
+                    return (String) LOCALE_METHOD.invoke(player.spigot());
+                } catch (IllegalAccessException | InvocationTargetException ignored) {
+                }
+            } else {
+                return player.getLocale();
+            }
+        }
+        return LanguageUtils.getDefaultLocale();
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/tech/skyouo/brilliant/geyser/Configuration.java b/src/main/java/tech/skyouo/brilliant/geyser/Configuration.java
new file mode 100644
index 0000000000000000000000000000000000000000..ca605cd93e6cc911ebb606bbf5b720a9a683d25c
--- /dev/null
+++ b/src/main/java/tech/skyouo/brilliant/geyser/Configuration.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ * @author GeyserMC
+ * @link https://github.com/GeyserMC/Geyser
+ */
+
+package tech.skyouo.brilliant.geyser;
+
+import com.fasterxml.jackson.annotation.JsonIgnore;
+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
+import lombok.Getter;
+import org.bukkit.Bukkit;
+import org.bukkit.plugin.Plugin;
+import org.geysermc.connector.FloodgateKeyLoader;
+import org.geysermc.connector.configuration.GeyserJacksonConfiguration;
+
+import java.nio.file.Path;
+import java.nio.file.Paths;
+
+@Getter
+@JsonIgnoreProperties(ignoreUnknown = true)
+public final class Configuration extends GeyserJacksonConfiguration {
+    @JsonIgnore
+    private Path floodgateKeyPath;
+
+    public void loadFloodgate(Bootstrap main) {
+        Plugin floodgate = Bukkit.getPluginManager().getPlugin("floodgate");
+        Path geyserDataFolder = Paths.get(System.getProperty("user.dir"));
+        Path floodgateDataFolder = floodgate != null ? floodgate.getDataFolder().toPath() : null;
+
+        floodgateKeyPath = FloodgateKeyLoader.getKeyPath(this, floodgateDataFolder, geyserDataFolder, main.getGeyserLogger());
+    }
+
+    public Path getFloodgateKeyPath() {
+        return floodgateKeyPath;
+    }
+
+    public void setFloodgateKeyPath(Path floodgateKeyPath) {
+        this.floodgateKeyPath = floodgateKeyPath;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/tech/skyouo/brilliant/geyser/Injector.java b/src/main/java/tech/skyouo/brilliant/geyser/Injector.java
new file mode 100644
index 0000000000000000000000000000000000000000..243185f0175826a54e384fde359717500331b3ea
--- /dev/null
+++ b/src/main/java/tech/skyouo/brilliant/geyser/Injector.java
@@ -0,0 +1,133 @@
+/*
+ * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ * @author GeyserMC
+ * @link https://github.com/GeyserMC/Geyser
+ */
+
+package tech.skyouo.brilliant.geyser;
+
+import com.github.steveice10.packetlib.io.local.LocalServerChannelWrapper;
+import com.viaversion.viaversion.bukkit.handlers.BukkitChannelInitializer;
+import io.netty.bootstrap.ServerBootstrap;
+import io.netty.channel.*;
+import io.netty.channel.local.LocalAddress;
+import io.netty.util.concurrent.DefaultThreadFactory;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.network.ServerConnectionListener;
+import org.geysermc.connector.bootstrap.GeyserBootstrap;
+import org.geysermc.connector.common.GeyserInjector;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.util.List;
+
+public class Injector extends GeyserInjector {
+    /**
+     * Used to determine if ViaVersion is setup to a state where Geyser players will fail at joining if injection is enabled
+     */
+    private final boolean isViaVersion;
+    /**
+     * Used to uninject ourselves on shutdown.
+     */
+    private List<ChannelFuture> allServerChannels;
+
+    public Injector(boolean isViaVersion) {
+        this.isViaVersion = isViaVersion;
+    }
+
+    @Override
+    @SuppressWarnings("unchecked")
+    protected void initializeLocalChannel0(GeyserBootstrap bootstrap) throws Exception {
+        MinecraftServer server = MinecraftServer.getServer(); // Brilliant - We are on 1.17+, and we can contract NMS.
+        ServerConnectionListener connection = server.getConnection();
+
+        allServerChannels = connection.getChannels();
+        // Find the channel that Minecraft uses to listen to connections
+        ChannelFuture listeningChannel = allServerChannels.get(0); // Brilliant - Avoid ugly reflect usage.
+
+        if (listeningChannel == null) {
+            throw new RuntimeException("Unable to find listening channel!");
+        }
+
+        // Making this a function prevents childHandler from being treated as a non-final variable
+        ChannelInitializer<Channel> childHandler = getChildHandler(bootstrap, listeningChannel);
+        // This method is what initializes the connection in Java Edition, after Netty is all set.
+        Method initChannel = childHandler.getClass().getDeclaredMethod("initChannel", Channel.class);
+        initChannel.setAccessible(true);
+
+        ChannelFuture channelFuture = (new ServerBootstrap()
+                .channel(LocalServerChannelWrapper.class)
+                .childHandler(new ChannelInitializer<Channel>() {
+                    @Override
+                    protected void initChannel(Channel ch) throws Exception {
+                        initChannel.invoke(childHandler, ch);
+                    }
+                })
+                // Set to MAX_PRIORITY as MultithreadEventLoopGroup#newDefaultThreadFactory which DefaultEventLoopGroup implements does by default
+                .group(new DefaultEventLoopGroup(0, new DefaultThreadFactory("Geyser connection thread", Thread.MAX_PRIORITY)))
+                .localAddress(LocalAddress.ANY))
+                .bind()
+                .syncUninterruptibly();
+        // We don't need to add to the list, but plugins like ProtocolSupport and ProtocolLib that add to the main pipeline
+        // will work when we add to the list.
+        allServerChannels.add(channelFuture);
+        this.localChannel = channelFuture;
+        this.serverSocketAddress = channelFuture.channel().localAddress();
+    }
+
+    @SuppressWarnings("unchecked")
+    private ChannelInitializer<Channel> getChildHandler(GeyserBootstrap bootstrap, ChannelFuture listeningChannel) {
+        List<String> names = listeningChannel.channel().pipeline().names();
+        ChannelInitializer<Channel> childHandler = null;
+        for (String name : names) {
+            ChannelHandler handler = listeningChannel.channel().pipeline().get(name);
+            try {
+                Field childHandlerField = handler.getClass().getDeclaredField("childHandler");
+                childHandlerField.setAccessible(true);
+                childHandler = (ChannelInitializer<Channel>) childHandlerField.get(handler);
+                // ViaVersion non-Paper-injector workaround so we aren't double-injecting
+                if (isViaVersion && childHandler instanceof BukkitChannelInitializer) {
+                    childHandler = ((BukkitChannelInitializer) childHandler).getOriginal();
+                }
+                break;
+            } catch (Exception e) {
+                if (bootstrap.getGeyserConfig().isDebugMode()) {
+                    bootstrap.getGeyserLogger().debug("The handler " + name + " isn't a ChannelInitializer. THIS ERROR IS SAFE TO IGNORE!");
+                    e.printStackTrace();
+                }
+            }
+        }
+        if (childHandler == null) {
+            throw new RuntimeException();
+        }
+        return childHandler;
+    }
+
+    @Override
+    public void shutdown() {
+        if (this.allServerChannels != null) {
+            this.allServerChannels.remove(this.localChannel);
+            this.allServerChannels = null;
+        }
+        super.shutdown();
+    }
+}
diff --git a/src/main/java/tech/skyouo/brilliant/geyser/Logging.java b/src/main/java/tech/skyouo/brilliant/geyser/Logging.java
new file mode 100644
index 0000000000000000000000000000000000000000..7083cdccff97cfc4807065d2c09f9b69f1a7fafe
--- /dev/null
+++ b/src/main/java/tech/skyouo/brilliant/geyser/Logging.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ * @author GeyserMC
+ * @link https://github.com/GeyserMC/Geyser
+ */
+
+package tech.skyouo.brilliant.geyser;
+
+import org.geysermc.connector.GeyserLogger;
+
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+public class Logging implements GeyserLogger {
+    private final Logger logger;
+    private boolean debug;
+
+    public Logging(Logger logger, boolean debug) {
+        this.logger = logger;
+        this.debug = debug;
+    }
+
+    @Override
+    public void severe(String message) {
+        logger.severe(message);
+    }
+
+    @Override
+    public void severe(String message, Throwable error) {
+        logger.log(Level.SEVERE, message, error);
+    }
+
+    @Override
+    public void error(String message) {
+        logger.warning(message);
+    }
+
+    @Override
+    public void error(String message, Throwable error) {
+        logger.log(Level.WARNING, message, error);
+    }
+
+    @Override
+    public void warning(String message) {
+        error(message);
+    }
+
+    @Override
+    public void info(String message) {
+        logger.info(message);
+    }
+
+    @Override
+    public void debug(String message) {
+        if (debug) {
+            info(message);
+        }
+    }
+
+    @Override
+    public boolean isDebug() {
+        return debug;
+    }
+
+    @Override
+    public void setDebug(boolean debug) {
+        this.debug = debug;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/tech/skyouo/brilliant/geyser/PingPassthrough.java b/src/main/java/tech/skyouo/brilliant/geyser/PingPassthrough.java
new file mode 100644
index 0000000000000000000000000000000000000000..e9cc0a934d8d740eef6c4b1f21f89ea7c3c0f55d
--- /dev/null
+++ b/src/main/java/tech/skyouo/brilliant/geyser/PingPassthrough.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ * @author GeyserMC
+ * @link https://github.com/GeyserMC/Geyser
+ */
+
+package tech.skyouo.brilliant.geyser;
+
+import com.github.steveice10.mc.protocol.MinecraftConstants;
+import org.bukkit.Bukkit;
+import org.bukkit.entity.Player;
+import org.bukkit.event.server.ServerListPingEvent;
+import org.bukkit.util.CachedServerIcon;
+import org.geysermc.connector.common.ping.GeyserPingInfo;
+import org.geysermc.connector.ping.IGeyserPingPassthrough;
+
+import javax.annotation.Nonnull;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.util.Collections;
+import java.util.Iterator;
+
+public class PingPassthrough implements IGeyserPingPassthrough {
+
+    private final Logging logger;
+
+    public PingPassthrough(Logging logger) {
+        this.logger = logger;
+    }
+
+    @Override
+    public GeyserPingInfo getPingInformation(InetSocketAddress inetSocketAddress) {
+        try {
+            ServerListPingEvent event = new GeyserPingEvent(inetSocketAddress.getAddress(), Bukkit.getMotd(), Bukkit.getOnlinePlayers().size(), Bukkit.getMaxPlayers());
+            Bukkit.getPluginManager().callEvent(event);
+            GeyserPingInfo geyserPingInfo = new GeyserPingInfo(event.getMotd(),
+                    new GeyserPingInfo.Players(event.getMaxPlayers(), event.getNumPlayers()),
+                    new GeyserPingInfo.Version(Bukkit.getVersion(), MinecraftConstants.PROTOCOL_VERSION) // thanks Spigot for not exposing this, just default to latest
+            );
+            Bukkit.getOnlinePlayers().stream().map(Player::getName).forEach(geyserPingInfo.getPlayerList()::add);
+            return geyserPingInfo;
+        } catch (Exception e) {
+            logger.debug("Error while getting Bukkit ping passthrough: " + e);
+            return new GeyserPingInfo(null, null, null);
+        }
+    }
+
+    // These methods are unimplemented on spigot api by default so we add stubs so plugins don't complain
+    private static class GeyserPingEvent extends ServerListPingEvent {
+
+        public GeyserPingEvent(InetAddress address, String motd, int numPlayers, int maxPlayers) {
+            super(address, motd, numPlayers, maxPlayers);
+        }
+
+        @Override
+        public void setServerIcon(CachedServerIcon icon) throws IllegalArgumentException, UnsupportedOperationException {
+        }
+
+        @Nonnull
+        @Override
+        public Iterator<Player> iterator() throws UnsupportedOperationException {
+            return Collections.emptyIterator();
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/src/main/java/tech/skyouo/brilliant/geyser/listener/BlockPlaceListener.java b/src/main/java/tech/skyouo/brilliant/geyser/listener/BlockPlaceListener.java
new file mode 100644
index 0000000000000000000000000000000000000000..f4b8be063246456592a11877cc0155bd6496e18f
--- /dev/null
+++ b/src/main/java/tech/skyouo/brilliant/geyser/listener/BlockPlaceListener.java
@@ -0,0 +1,47 @@
+package tech.skyouo.brilliant.geyser.listener;
+
+import com.nukkitx.math.vector.Vector3f;
+import com.nukkitx.protocol.bedrock.data.SoundEvent;
+import com.nukkitx.protocol.bedrock.packet.LevelSoundEventPacket;
+import org.bukkit.event.EventHandler;
+import org.bukkit.event.Listener;
+import org.bukkit.event.block.BlockPlaceEvent;
+import org.geysermc.connector.GeyserConnector;
+import org.geysermc.connector.network.session.GeyserSession;
+import org.geysermc.connector.network.translators.world.block.BlockStateValues;
+import org.geysermc.connector.registry.BlockRegistries;
+import tech.skyouo.brilliant.geyser.world.BaseWorldManager;
+
+public class BlockPlaceListener implements Listener {
+    private final GeyserConnector connector;
+    private final BaseWorldManager worldManager;
+
+    public BlockPlaceListener(GeyserConnector connector, BaseWorldManager worldManager) {
+        this.connector = connector;
+        this.worldManager = worldManager;
+    }
+
+    @EventHandler
+    public void place(final BlockPlaceEvent event) {
+        GeyserSession session = connector.getPlayerByUuid(event.getPlayer().getUniqueId());
+        if (session == null) {
+            return;
+        }
+
+        LevelSoundEventPacket placeBlockSoundPacket = new LevelSoundEventPacket();
+        placeBlockSoundPacket.setSound(SoundEvent.PLACE);
+        placeBlockSoundPacket.setPosition(Vector3f.from(event.getBlockPlaced().getX(), event.getBlockPlaced().getY(), event.getBlockPlaced().getZ()));
+        placeBlockSoundPacket.setBabySound(false);
+        if (worldManager.isLegacy()) {
+            placeBlockSoundPacket.setExtraData(session.getBlockMappings().getBedrockBlockId(worldManager.getBlockAt(session,
+                    event.getBlockPlaced().getX(), event.getBlockPlaced().getY(), event.getBlockPlaced().getZ())));
+        } else {
+            String javaBlockId = event.getBlockPlaced().getBlockData().getAsString();
+            placeBlockSoundPacket.setExtraData(session.getBlockMappings().getBedrockBlockId(BlockRegistries.JAVA_IDENTIFIERS.get().getOrDefault(javaBlockId, BlockStateValues.JAVA_AIR_ID)));
+        }
+        placeBlockSoundPacket.setIdentifier(":");
+        session.sendUpstreamPacket(placeBlockSoundPacket);
+        session.setLastBlockPlacePosition(null);
+        session.setLastBlockPlacedId(null);
+    }
+}
diff --git a/src/main/java/tech/skyouo/brilliant/geyser/listener/CraftingListener1_11.java b/src/main/java/tech/skyouo/brilliant/geyser/listener/CraftingListener1_11.java
new file mode 100644
index 0000000000000000000000000000000000000000..ab7a7d08ad092ad5e696baea3e151ddc32d76455
--- /dev/null
+++ b/src/main/java/tech/skyouo/brilliant/geyser/listener/CraftingListener1_11.java
@@ -0,0 +1,203 @@
+/*
+ * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ * @author GeyserMC
+ * @link https://github.com/GeyserMC/Geyser
+ */
+
+package tech.skyouo.brilliant.geyser.listener;
+
+import com.github.steveice10.mc.protocol.MinecraftConstants;
+import com.github.steveice10.mc.protocol.data.game.entity.metadata.ItemStack;
+import com.github.steveice10.mc.protocol.data.game.recipe.Ingredient;
+import com.github.steveice10.mc.protocol.data.game.recipe.RecipeType;
+import com.github.steveice10.mc.protocol.data.game.recipe.data.ShapedRecipeData;
+import com.github.steveice10.mc.protocol.data.game.recipe.data.ShapelessRecipeData;
+import com.nukkitx.protocol.bedrock.data.inventory.CraftingData;
+import com.nukkitx.protocol.bedrock.data.inventory.ItemData;
+import com.nukkitx.protocol.bedrock.packet.CraftingDataPacket;
+import com.viaversion.viaversion.api.Via;
+import com.viaversion.viaversion.api.data.MappingData;
+import com.viaversion.viaversion.api.protocol.ProtocolPathEntry;
+import com.viaversion.viaversion.api.protocol.version.ProtocolVersion;
+import com.viaversion.viaversion.protocols.protocol1_13to1_12_2.Protocol1_13To1_12_2;
+import com.viaversion.viaversion.util.Pair;
+import org.bukkit.Bukkit;
+import org.bukkit.event.EventHandler;
+import org.bukkit.event.Listener;
+import org.bukkit.event.player.PlayerJoinEvent;
+import org.bukkit.inventory.Recipe;
+import org.bukkit.inventory.ShapedRecipe;
+import org.bukkit.inventory.ShapelessRecipe;
+import org.geysermc.connector.GeyserConnector;
+import org.geysermc.connector.network.session.GeyserSession;
+import org.geysermc.connector.network.translators.item.ItemTranslator;
+import org.geysermc.connector.utils.InventoryUtils;
+
+import java.util.*;
+
+/**
+ * Used to send all available recipes from the server to the client, as a valid recipe book packet won't be sent by the server.
+ * Requires ViaVersion.
+ */
+public class CraftingListener1_11 implements Listener {
+
+    private final GeyserConnector connector;
+    /**
+     * Specific mapping data for 1.12 to 1.13. Used to convert the 1.12 item into 1.13.
+     */
+    private final MappingData mappingData1_12to1_13;
+    /**
+     * The list of all protocols from the client's version to 1.13.
+     */
+    private final List<ProtocolPathEntry> protocolList;
+
+    public CraftingListener1_11(GeyserConnector connector) {
+        this.connector = connector;
+        this.mappingData1_12to1_13 = Via.getManager().getProtocolManager().getProtocol(Protocol1_13To1_12_2.class).getMappingData();
+        this.protocolList = Via.getManager().getProtocolManager().getProtocolPath(MinecraftConstants.PROTOCOL_VERSION,
+                ProtocolVersion.v1_13.getVersion());
+    }
+
+    @EventHandler
+    public void onPlayerJoin(PlayerJoinEvent event) {
+        GeyserSession session = null;
+        for (GeyserSession otherSession : connector.getSessionManager().getSessions().values()) {
+            if (otherSession.getName().equals(event.getPlayer().getName())) {
+                session = otherSession;
+                break;
+            }
+        }
+        if (session == null) {
+            return;
+        }
+
+        sendServerRecipes(session);
+    }
+
+    public void sendServerRecipes(GeyserSession session) {
+        int netId = InventoryUtils.LAST_RECIPE_NET_ID;
+
+        CraftingDataPacket craftingDataPacket = new CraftingDataPacket();
+        craftingDataPacket.setCleanRecipes(true);
+
+        Iterator<Recipe> recipeIterator = Bukkit.getServer().recipeIterator();
+        while (recipeIterator.hasNext()) {
+            Recipe recipe = recipeIterator.next();
+
+            Pair<ItemStack, ItemData> outputs = translateToBedrock(session, recipe.getResult());
+            ItemStack javaOutput = outputs.getKey();
+            ItemData output = outputs.getValue();
+            if (output == null || output.getId() == 0) continue; // If items make air we don't want that
+
+            boolean isNotAllAir = false; // Check for all-air recipes
+            if (recipe instanceof ShapedRecipe shapedRecipe) {
+                int size = shapedRecipe.getShape().length * shapedRecipe.getShape()[0].length();
+                Ingredient[] ingredients = new Ingredient[size];
+                ItemData[] input = new ItemData[size];
+                for (int i = 0; i < input.length; i++) {
+                    // Index is converting char to integer, adding i then converting back to char based on ASCII code
+                    Pair<ItemStack, ItemData> result = translateToBedrock(session, shapedRecipe.getIngredientMap().get((char) ('a' + i)));
+                    ingredients[i] = new Ingredient(new ItemStack[]{result.getKey()});
+                    input[i] = result.getValue();
+                    isNotAllAir |= input[i].getId() != 0;
+                }
+
+                if (!isNotAllAir) continue;
+                UUID uuid = UUID.randomUUID();
+                // Add recipe to our internal cache
+                ShapedRecipeData data = new ShapedRecipeData(shapedRecipe.getShape()[0].length(), shapedRecipe.getShape().length,
+                        "", ingredients, javaOutput);
+                session.getCraftingRecipes().put(netId,
+                        new com.github.steveice10.mc.protocol.data.game.recipe.Recipe(RecipeType.CRAFTING_SHAPED, uuid.toString(), data));
+
+                // Add recipe for Bedrock
+                craftingDataPacket.getCraftingData().add(CraftingData.fromShaped(uuid.toString(),
+                        shapedRecipe.getShape()[0].length(), shapedRecipe.getShape().length, Arrays.asList(input),
+                        Collections.singletonList(output), uuid, "crafting_table", 0, netId++));
+            } else if (recipe instanceof ShapelessRecipe shapelessRecipe) {
+                Ingredient[] ingredients = new Ingredient[shapelessRecipe.getIngredientList().size()];
+                ItemData[] input = new ItemData[shapelessRecipe.getIngredientList().size()];
+
+                for (int i = 0; i < input.length; i++) {
+                    Pair<ItemStack, ItemData> result = translateToBedrock(session, shapelessRecipe.getIngredientList().get(i));
+                    ingredients[i] = new Ingredient(new ItemStack[]{result.getKey()});
+                    input[i] = result.getValue();
+                    isNotAllAir |= input[i].getId() != 0;
+                }
+
+                if (!isNotAllAir) continue;
+                UUID uuid = UUID.randomUUID();
+                // Add recipe to our internal cache
+                ShapelessRecipeData data = new ShapelessRecipeData("", ingredients, javaOutput);
+                session.getCraftingRecipes().put(netId,
+                        new com.github.steveice10.mc.protocol.data.game.recipe.Recipe(RecipeType.CRAFTING_SHAPELESS, uuid.toString(), data));
+
+                // Add recipe for Bedrock
+                craftingDataPacket.getCraftingData().add(CraftingData.fromShapeless(uuid.toString(),
+                        Arrays.asList(input), Collections.singletonList(output), uuid, "crafting_table", 0, netId++));
+            }
+        }
+
+        session.sendUpstreamPacket(craftingDataPacket);
+    }
+
+    @SuppressWarnings("deprecation")
+    private Pair<ItemStack, ItemData> translateToBedrock(GeyserSession session, org.bukkit.inventory.ItemStack itemStack) {
+        if (itemStack != null && itemStack.getData() != null) {
+            if (itemStack.getType().getId() == 0) {
+                return new Pair<>(null, ItemData.AIR);
+            }
+
+            int legacyId = (itemStack.getType().getId() << 4) | (itemStack.getData().getData() & 0xFFFF);
+
+            if (itemStack.getType().getId() == 355 && itemStack.getData().getData() == (byte) 0) { // Handle bed color since the server will always be pre-1.12
+                legacyId = (itemStack.getType().getId() << 4) | ((byte) 14 & 0xFFFF);
+            }
+
+            // old version -> 1.13 -> 1.13.1 -> 1.14 -> 1.15 -> 1.16 and so on
+            int itemId;
+            if (mappingData1_12to1_13.getItemMappings().containsKey(legacyId)) {
+                itemId = mappingData1_12to1_13.getNewItemId(legacyId);
+            } else if (mappingData1_12to1_13.getItemMappings().containsKey((itemStack.getType().getId() << 4) | (0))) {
+                itemId = mappingData1_12to1_13.getNewItemId((itemStack.getType().getId() << 4) | (0));
+            } else {
+                // No ID found, just send back air
+                return new Pair<>(null, ItemData.AIR);
+            }
+
+            for (int i = protocolList.size() - 1; i >= 0; i--) {
+                MappingData mappingData = protocolList.get(i).getProtocol().getMappingData();
+                if (mappingData != null) {
+                    itemId = mappingData.getNewItemId(itemId);
+                }
+            }
+
+            ItemStack mcItemStack = new ItemStack(itemId, itemStack.getAmount());
+            ItemData finalData = ItemTranslator.translateToBedrock(session, mcItemStack);
+            return new Pair<>(mcItemStack, finalData);
+        }
+
+        // Empty slot, most likely
+        return new Pair<>(null, ItemData.AIR);
+    }
+
+}
\ No newline at end of file
diff --git a/src/main/java/tech/skyouo/brilliant/geyser/listener/PistonListener.java b/src/main/java/tech/skyouo/brilliant/geyser/listener/PistonListener.java
new file mode 100644
index 0000000000000000000000000000000000000000..af475021ffcbee39d6d3ac5a383112a7d4a480d8
--- /dev/null
+++ b/src/main/java/tech/skyouo/brilliant/geyser/listener/PistonListener.java
@@ -0,0 +1,140 @@
+/*
+ * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ * @author GeyserMC
+ * @link https://github.com/GeyserMC/Geyser
+ */
+
+package tech.skyouo.brilliant.geyser.listener;
+
+
+import com.github.steveice10.mc.protocol.data.game.world.block.value.PistonValueType;
+import com.nukkitx.math.vector.Vector3i;
+import it.unimi.dsi.fastutil.objects.Object2IntMap;
+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.block.Block;
+import org.bukkit.entity.Player;
+import org.bukkit.event.EventHandler;
+import org.bukkit.event.EventPriority;
+import org.bukkit.event.Listener;
+import org.bukkit.event.block.BlockPistonEvent;
+import org.bukkit.event.block.BlockPistonExtendEvent;
+import org.bukkit.event.block.BlockPistonRetractEvent;
+import org.geysermc.connector.GeyserConnector;
+import org.geysermc.connector.network.session.GeyserSession;
+import org.geysermc.connector.network.session.cache.PistonCache;
+import org.geysermc.connector.network.translators.world.block.BlockStateValues;
+import org.geysermc.connector.network.translators.world.block.entity.PistonBlockEntity;
+import org.geysermc.connector.utils.Direction;
+import tech.skyouo.brilliant.geyser.world.BaseWorldManager;
+
+import java.util.List;
+import java.util.Map;
+import java.util.UUID;
+
+public class PistonListener implements Listener {
+    private final GeyserConnector connector;
+    private final BaseWorldManager worldManager;
+
+    public PistonListener(GeyserConnector connector, BaseWorldManager worldManager) {
+        this.connector = connector;
+        this.worldManager = worldManager;
+    }
+
+    // The handlers' parent class cannot be registered
+    @EventHandler(priority = EventPriority.MONITOR)
+    public void onPistonExtend(BlockPistonExtendEvent event) {
+        onPistonAction(event);
+    }
+
+    @EventHandler(priority = EventPriority.MONITOR)
+    public void onPistonRetract(BlockPistonRetractEvent event) {
+        onPistonAction(event);
+    }
+
+    private void onPistonAction(BlockPistonEvent event) {
+        if (event.isCancelled()) {
+            return;
+        }
+
+        World world = event.getBlock().getWorld();
+        boolean isExtend = event instanceof BlockPistonExtendEvent;
+
+        Location location = event.getBlock().getLocation();
+        Vector3i position = getVector(location);
+        PistonValueType type = isExtend ? PistonValueType.PUSHING : PistonValueType.PULLING;
+        boolean sticky = event.isSticky();
+
+        Object2IntMap<Vector3i> attachedBlocks = new Object2IntOpenHashMap<>();
+        boolean blocksFilled = false;
+
+        for (Map.Entry<UUID, GeyserSession> entry : connector.getSessionManager().getSessions().entrySet()) {
+            Player player = Bukkit.getPlayer(entry.getKey());
+            if (player == null || !player.getWorld().equals(world)) {
+                continue;
+            }
+            GeyserSession session = entry.getValue();
+
+            int dX = Math.abs(location.getBlockX() - player.getLocation().getBlockX()) >> 4;
+            int dZ = Math.abs(location.getBlockZ() - player.getLocation().getBlockZ()) >> 4;
+            if ((dX * dX + dZ * dZ) > session.getRenderDistance() * session.getRenderDistance()) {
+                // Ignore pistons outside the player's render distance
+                continue;
+            }
+
+            // Trying to grab the blocks from the world like other platforms would result in the moving piston block
+            // being returned instead.
+            if (!blocksFilled) {
+                // Blocks currently require a player for 1.12, so let's just leech off one player to get all blocks
+                // and call it a day for the rest of the sessions (mostly to save on execution time)
+                List<Block> blocks = isExtend ? ((BlockPistonExtendEvent) event).getBlocks() : ((BlockPistonRetractEvent) event).getBlocks();
+                for (Block block : blocks) {
+                    Location attachedLocation = block.getLocation();
+                    int blockId = worldManager.getBlockNetworkId(player, block,
+                            attachedLocation.getBlockX(), attachedLocation.getBlockY(), attachedLocation.getBlockZ());
+                    // Ignore blocks that will be destroyed
+                    if (BlockStateValues.canPistonMoveBlock(blockId, isExtend)) {
+                        attachedBlocks.put(getVector(attachedLocation), blockId);
+                    }
+                }
+                blocksFilled = true;
+            }
+
+            int pistonBlockId = worldManager.getBlockNetworkId(player, event.getBlock(), location.getBlockX(), location.getBlockY(), location.getBlockZ());
+            // event.getDirection() is unreliable
+            Direction orientation = BlockStateValues.getPistonOrientation(pistonBlockId);
+
+            session.executeInEventLoop(() -> {
+                PistonCache pistonCache = session.getPistonCache();
+                PistonBlockEntity blockEntity = pistonCache.getPistons().computeIfAbsent(position, pos ->
+                        new PistonBlockEntity(session, position, orientation, sticky, !isExtend));
+                blockEntity.setAction(type, attachedBlocks);
+            });
+        }
+    }
+
+    private Vector3i getVector(Location location) {
+        return Vector3i.from(location.getX(), location.getY(), location.getZ());
+    }
+}
diff --git a/src/main/java/tech/skyouo/brilliant/geyser/world/BaseWorldManager.java b/src/main/java/tech/skyouo/brilliant/geyser/world/BaseWorldManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..45ca27cf8792f6666e9ac3d1ca2cd49c01356f0b
--- /dev/null
+++ b/src/main/java/tech/skyouo/brilliant/geyser/world/BaseWorldManager.java
@@ -0,0 +1,195 @@
+/*
+ * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ * @author GeyserMC
+ * @link https://github.com/GeyserMC/Geyser
+ */
+
+package tech.skyouo.brilliant.geyser.world;
+
+import com.github.steveice10.mc.protocol.MinecraftConstants;
+import com.nukkitx.math.vector.Vector3i;
+import com.nukkitx.nbt.NbtMap;
+import com.nukkitx.nbt.NbtMapBuilder;
+import com.nukkitx.nbt.NbtType;
+import org.bukkit.Bukkit;
+import org.bukkit.World;
+import org.bukkit.block.Block;
+import org.bukkit.block.Lectern;
+import org.bukkit.block.data.BlockData;
+import org.bukkit.entity.Player;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.inventory.meta.BookMeta;
+import org.bukkit.plugin.Plugin;
+import org.geysermc.connector.network.session.GeyserSession;
+import org.geysermc.connector.network.translators.inventory.translators.LecternInventoryTranslator;
+import org.geysermc.connector.network.translators.world.GeyserWorldManager;
+import org.geysermc.connector.network.translators.world.block.BlockStateValues;
+import org.geysermc.connector.registry.BlockRegistries;
+import org.geysermc.connector.utils.BlockEntityUtils;
+import org.geysermc.connector.utils.GameRule;
+import tech.skyouo.brilliant.geyser.world.dummy.FakePlugin;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * The base world manager to use when there is no supported NMS revision
+ */
+public class BaseWorldManager extends GeyserWorldManager {
+    /**
+     * The current client protocol version for ViaVersion usage.
+     */
+    protected static final int CLIENT_PROTOCOL_VERSION = MinecraftConstants.PROTOCOL_VERSION;
+
+    private final Plugin plugin;
+
+    public BaseWorldManager() {
+        this.plugin = new FakePlugin("GeyserWorldManager");
+    }
+
+    @Override
+    public int getBlockAt(GeyserSession session, int x, int y, int z) {
+        Player bukkitPlayer;
+        if ((bukkitPlayer = Bukkit.getPlayer(session.getPlayerEntity().getUsername())) == null) {
+            return BlockStateValues.JAVA_AIR_ID;
+        }
+        World world = bukkitPlayer.getWorld();
+        if (!world.isChunkLoaded(x >> 4, z >> 4)) {
+            // If the chunk isn't loaded, how could we even be here?
+            return BlockStateValues.JAVA_AIR_ID;
+        }
+
+        return getBlockNetworkId(bukkitPlayer, world.getBlockAt(x, y, z), x, y, z);
+    }
+
+    public int getBlockNetworkId(Player player, Block block, int x, int y, int z) {
+        return BlockRegistries.JAVA_IDENTIFIERS.getOrDefault(block.getBlockData().getAsString(), BlockStateValues.JAVA_AIR_ID);
+    }
+
+    @Override
+    public boolean hasOwnChunkCache() {
+        return true;
+    }
+
+    @Override
+    public NbtMap getLecternDataAt(GeyserSession session, int x, int y, int z, boolean isChunkLoad) {
+        // Run as a task to prevent async issues
+        Runnable lecternInfoGet = () -> {
+            Player bukkitPlayer;
+            if ((bukkitPlayer = Bukkit.getPlayer(session.getPlayerEntity().getUsername())) == null) {
+                return;
+            }
+
+            Block block = bukkitPlayer.getWorld().getBlockAt(x, y, z);
+            if (!(block.getState() instanceof Lectern lectern)) {
+                session.getConnector().getLogger().error("Lectern expected at: " + Vector3i.from(x, y, z).toString() + " but was not! " + block.toString());
+                return;
+            }
+
+            ItemStack itemStack = lectern.getInventory().getItem(0);
+            if (itemStack == null || !(itemStack.getItemMeta() instanceof BookMeta bookMeta)) {
+                if (!isChunkLoad) {
+                    // We need to update the lectern since it's not going to be updated otherwise
+                    BlockEntityUtils.updateBlockEntity(session, LecternInventoryTranslator.getBaseLecternTag(x, y, z, 0).build(), Vector3i.from(x, y, z));
+                }
+                // We don't care; return
+                return;
+            }
+
+            // On the count: allow the book to show/open even there are no pages. We know there is a book here, after all, and this matches Java behavior
+            boolean hasBookPages = bookMeta.getPageCount() > 0;
+            NbtMapBuilder lecternTag = LecternInventoryTranslator.getBaseLecternTag(x, y, z, hasBookPages ? bookMeta.getPageCount() : 1);
+            lecternTag.putInt("page", lectern.getPage() / 2);
+            NbtMapBuilder bookTag = NbtMap.builder()
+                    .putByte("Count", (byte) itemStack.getAmount())
+                    .putShort("Damage", (short) 0)
+                    .putString("Name", "minecraft:writable_book");
+            List<NbtMap> pages = new ArrayList<>(bookMeta.getPageCount());
+            if (hasBookPages) {
+                for (String page : bookMeta.getPages()) {
+                    NbtMapBuilder pageBuilder = NbtMap.builder()
+                            .putString("photoname", "")
+                            .putString("text", page);
+                    pages.add(pageBuilder.build());
+                }
+            } else {
+                // Empty page
+                NbtMapBuilder pageBuilder = NbtMap.builder()
+                        .putString("photoname", "")
+                        .putString("text", "");
+                pages.add(pageBuilder.build());
+            }
+
+            bookTag.putCompound("tag", NbtMap.builder().putList("pages", NbtType.COMPOUND, pages).build());
+            lecternTag.putCompound("book", bookTag.build());
+            NbtMap blockEntityTag = lecternTag.build();
+            BlockEntityUtils.updateBlockEntity(session, blockEntityTag, Vector3i.from(x, y, z));
+        };
+
+        if (isChunkLoad) {
+            // Delay to ensure the chunk is sent first, and then the lectern data
+            Bukkit.getScheduler().runTaskLater(this.plugin, lecternInfoGet, 5);
+        } else {
+            Bukkit.getScheduler().runTask(this.plugin, lecternInfoGet);
+        }
+        return LecternInventoryTranslator.getBaseLecternTag(x, y, z, 0).build(); // Will be updated later
+    }
+
+    @Override
+    public boolean shouldExpectLecternHandled() {
+        return true;
+    }
+
+    public Boolean getGameRuleBool(GeyserSession session, GameRule gameRule) {
+        String value = Bukkit.getPlayer(session.getPlayerEntity().getUsername()).getWorld().getGameRuleValue(gameRule.getJavaID());
+        if (!value.isEmpty()) {
+            return Boolean.parseBoolean(value);
+        }
+        return (Boolean) gameRule.getDefaultValue();
+    }
+
+    @Override
+    public int getGameRuleInt(GeyserSession session, GameRule gameRule) {
+        String value = Bukkit.getPlayer(session.getPlayerEntity().getUsername()).getWorld().getGameRuleValue(gameRule.getJavaID());
+        if (!value.isEmpty()) {
+            return Integer.parseInt(value);
+        }
+        return (int) gameRule.getDefaultValue();
+    }
+
+    @Override
+    public boolean hasPermission(GeyserSession session, String permission) {
+        return Bukkit.getPlayer(session.getPlayerEntity().getUsername()).hasPermission(permission);
+    }
+
+    /**
+     * This must be set to true if we are pre-1.13, and {@link BlockData#getAsString() does not exist}.
+     *
+     * This should be set to true if we are post-1.13 but before the latest version, and we should convert the old block state id
+     * to the current one.
+     *
+     * @return whether there is a difference between client block state and server block state that requires extra processing
+     */
+    public boolean isLegacy() {
+        return false;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/tech/skyouo/brilliant/geyser/world/FallbackWorldManager.java b/src/main/java/tech/skyouo/brilliant/geyser/world/FallbackWorldManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..6c5352d1b0e6455daf612b0537881df8494c3f15
--- /dev/null
+++ b/src/main/java/tech/skyouo/brilliant/geyser/world/FallbackWorldManager.java
@@ -0,0 +1,30 @@
+package tech.skyouo.brilliant.geyser.world;
+
+import org.geysermc.connector.network.session.GeyserSession;
+import org.geysermc.connector.network.translators.world.block.BlockStateValues;
+
+/**
+ * Should only be used when we know {@link BaseWorldManager#getBlockAt(GeyserSession, int, int, int)}
+ * cannot be accurate. Typically, this is when ViaVersion is not installed but a client still manages to connect.
+ * If this occurs to you somehow, please let us know!!
+ */
+public class FallbackWorldManager extends BaseWorldManager {
+    public FallbackWorldManager() {
+        super();
+    }
+
+    @Override
+    public int getBlockAt(GeyserSession session, int x, int y, int z) {
+        return BlockStateValues.JAVA_AIR_ID;
+    }
+
+    @Override
+    public boolean hasOwnChunkCache() {
+        return false;
+    }
+
+    @Override
+    public boolean isLegacy() {
+        return true;
+    }
+}
diff --git a/src/main/java/tech/skyouo/brilliant/geyser/world/LegacyNativeWorldManager.java b/src/main/java/tech/skyouo/brilliant/geyser/world/LegacyNativeWorldManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..8bd783ec927c48ecaef11bc9612a35db6fed127b
--- /dev/null
+++ b/src/main/java/tech/skyouo/brilliant/geyser/world/LegacyNativeWorldManager.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ * @author GeyserMC
+ * @link https://github.com/GeyserMC/Geyser
+ */
+
+package tech.skyouo.brilliant.geyser.world;
+
+import com.github.steveice10.mc.protocol.MinecraftConstants;
+import com.viaversion.viaversion.api.Via;
+import com.viaversion.viaversion.api.data.MappingData;
+import com.viaversion.viaversion.api.protocol.ProtocolPathEntry;
+import com.viaversion.viaversion.api.protocol.version.ProtocolVersion;
+import it.unimi.dsi.fastutil.ints.Int2IntMap;
+import it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap;
+import it.unimi.dsi.fastutil.ints.IntList;
+import org.geysermc.connector.network.session.GeyserSession;
+
+import java.util.List;
+
+/**
+ * Used when block IDs need to be translated to the latest version
+ */
+public class LegacyNativeWorldManager extends NativeWorldManager {
+
+    private final Int2IntMap oldToNewBlockId;
+
+    public LegacyNativeWorldManager(ProtocolVersion protocolVersion) {
+        super();
+        IntList allBlockStates = adapter.getAllBlockStates();
+        oldToNewBlockId = new Int2IntOpenHashMap(allBlockStates.size());
+        ProtocolVersion serverVersion = protocolVersion;
+        List<ProtocolPathEntry> protocolList = Via.getManager().getProtocolManager().getProtocolPath(MinecraftConstants.PROTOCOL_VERSION,
+                serverVersion.getVersion());
+        for (int oldBlockId : allBlockStates) {
+            int newBlockId = oldBlockId;
+            // protocolList should *not* be null; we checked for that before initializing this class
+            for (int i = protocolList.size() - 1; i >= 0; i--) {
+                MappingData mappingData = protocolList.get(i).getProtocol().getMappingData();
+                if (mappingData != null) {
+                    newBlockId = mappingData.getNewBlockStateId(newBlockId);
+                }
+            }
+            oldToNewBlockId.put(oldBlockId, newBlockId);
+        }
+    }
+
+    @Override
+    public int getBlockAt(GeyserSession session, int x, int y, int z) {
+        int nativeBlockId = super.getBlockAt(session, x, y, z);
+        return oldToNewBlockId.getOrDefault(nativeBlockId, nativeBlockId);
+    }
+
+    @Override
+    public boolean isLegacy() {
+        return true;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/tech/skyouo/brilliant/geyser/world/NativeWorldManager.java b/src/main/java/tech/skyouo/brilliant/geyser/world/NativeWorldManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..6752dca18bf834226f673e8fe99649dbf6a5acfd
--- /dev/null
+++ b/src/main/java/tech/skyouo/brilliant/geyser/world/NativeWorldManager.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ * @author GeyserMC
+ * @link https://github.com/GeyserMC/Geyser
+ */
+
+package tech.skyouo.brilliant.geyser.world;
+
+import org.bukkit.Bukkit;
+import org.bukkit.entity.Player;
+import org.bukkit.plugin.Plugin;
+import org.geysermc.connector.network.session.GeyserSession;
+import org.geysermc.connector.network.translators.world.block.BlockStateValues;
+import org.geysermc.geyser.adapters.spigot.SpigotAdapters;
+import org.geysermc.geyser.adapters.spigot.SpigotWorldAdapter;
+
+public class NativeWorldManager extends BaseWorldManager {
+    protected final SpigotWorldAdapter adapter;
+
+    public NativeWorldManager() {
+        super();
+        adapter = SpigotAdapters.getWorldAdapter();
+    }
+
+    @Override
+    public int getBlockAt(GeyserSession session, int x, int y, int z) {
+        Player player = Bukkit.getPlayer(session.getPlayerEntity().getUsername());
+        if (player == null) {
+            return BlockStateValues.JAVA_AIR_ID;
+        }
+        return adapter.getBlockAt(player.getWorld(), x, y, z);
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/tech/skyouo/brilliant/geyser/world/NativeWorldManager1_12.java b/src/main/java/tech/skyouo/brilliant/geyser/world/NativeWorldManager1_12.java
new file mode 100644
index 0000000000000000000000000000000000000000..7fa0af4775e099289a3754defe2ad96667214164
--- /dev/null
+++ b/src/main/java/tech/skyouo/brilliant/geyser/world/NativeWorldManager1_12.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ * @author GeyserMC
+ * @link https://github.com/GeyserMC/Geyser
+ */
+
+package org.geysermc.platform.spigot.world.manager;
+
+import com.viaversion.viaversion.api.Via;
+import com.viaversion.viaversion.protocols.protocol1_13to1_12_2.storage.BlockStorage;
+import org.bukkit.Bukkit;
+import org.bukkit.entity.Player;
+import org.bukkit.plugin.Plugin;
+import org.geysermc.connector.network.session.GeyserSession;
+import org.geysermc.connector.network.translators.world.block.BlockStateValues;
+import org.geysermc.geyser.adapters.spigot.SpigotAdapters;
+import org.geysermc.geyser.adapters.spigot.SpigotWorldAdapter;
+import tech.skyouo.brilliant.geyser.world.WorldManager1_12;
+
+/**
+ * Used with ViaVersion and pre-1.13.
+ */
+public class NativeWorldManager1_12 extends WorldManager1_12 {
+    private final SpigotWorldAdapter adapter;
+
+    public NativeWorldManager1_12() {
+        super();
+        this.adapter = SpigotAdapters.getWorldAdapter();
+        // Unlike post-1.13, we can't build up a cache of block states, because block entities need some special conversion
+    }
+
+    @Override
+    public int getBlockAt(GeyserSession session, int x, int y, int z) {
+        Player player = Bukkit.getPlayer(session.getPlayerEntity().getUsername());
+        if (player == null) {
+            return BlockStateValues.JAVA_AIR_ID;
+        }
+        // Get block entity storage
+        BlockStorage storage = Via.getManager().getConnectionManager().getConnectedClient(player.getUniqueId()).get(BlockStorage.class);
+        int blockId = adapter.getBlockAt(player.getWorld(), x, y, z);
+        return getLegacyBlock(storage, blockId, x, y, z);
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/tech/skyouo/brilliant/geyser/world/WorldManager1_12.java b/src/main/java/tech/skyouo/brilliant/geyser/world/WorldManager1_12.java
new file mode 100644
index 0000000000000000000000000000000000000000..e996ffd577268428a3be180945c56663d51d12a7
--- /dev/null
+++ b/src/main/java/tech/skyouo/brilliant/geyser/world/WorldManager1_12.java
@@ -0,0 +1,124 @@
+/*
+ * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ * @author GeyserMC
+ * @link https://github.com/GeyserMC/Geyser
+ */
+
+package tech.skyouo.brilliant.geyser.world;
+
+import com.viaversion.viaversion.api.Via;
+import com.viaversion.viaversion.api.data.MappingData;
+import com.viaversion.viaversion.api.minecraft.Position;
+import com.viaversion.viaversion.api.protocol.ProtocolPathEntry;
+import com.viaversion.viaversion.api.protocol.version.ProtocolVersion;
+import com.viaversion.viaversion.protocols.protocol1_13to1_12_2.Protocol1_13To1_12_2;
+import com.viaversion.viaversion.protocols.protocol1_13to1_12_2.storage.BlockStorage;
+import org.bukkit.Bukkit;
+import org.bukkit.block.Block;
+import org.bukkit.entity.Player;
+import org.geysermc.connector.network.session.GeyserSession;
+import org.geysermc.connector.network.translators.world.block.BlockStateValues;
+
+import java.util.List;
+
+/**
+ * Should be used when ViaVersion is present, no NMS adapter is being used, and we are pre-1.13.
+ *
+ * You need ViaVersion to connect to an older server with the Geyser-Spigot plugin.
+ */
+public class WorldManager1_12 extends BaseWorldManager {
+    /**
+     * Specific mapping data for 1.12 to 1.13. Used to convert the 1.12 block into the 1.13 block state.
+     * (Block IDs did not change between server versions until 1.13 and after)
+     */
+    private final MappingData mappingData1_12to1_13;
+
+    /**
+     * The list of all protocols from the client's version to 1.13.
+     */
+    private final List<ProtocolPathEntry> protocolList;
+
+    public WorldManager1_12() {
+        super();
+        this.mappingData1_12to1_13 = Via.getManager().getProtocolManager().getProtocol(Protocol1_13To1_12_2.class).getMappingData();
+        this.protocolList = Via.getManager().getProtocolManager().getProtocolPath(CLIENT_PROTOCOL_VERSION,
+                ProtocolVersion.v1_13.getVersion());
+    }
+
+    @Override
+    public int getBlockAt(GeyserSession session, int x, int y, int z) {
+        Player player = Bukkit.getPlayer(session.getPlayerEntity().getUsername());
+        if (player == null) {
+            return BlockStateValues.JAVA_AIR_ID;
+        }
+        if (!player.getWorld().isChunkLoaded(x >> 4, z >> 4)) {
+            // Prevent nasty async errors if a player is loading in
+            return BlockStateValues.JAVA_AIR_ID;
+        }
+
+        Block block = player.getWorld().getBlockAt(x, y, z);
+        return getBlockNetworkId(player, block, x, y, z);
+    }
+
+    @Override
+    @SuppressWarnings("deprecation")
+    public int getBlockNetworkId(Player player, Block block, int x, int y, int z) {
+        // Get block entity storage
+        BlockStorage storage = Via.getManager().getConnectionManager().getConnectedClient(player.getUniqueId()).get(BlockStorage.class);
+        // Black magic that gets the old block state ID
+        int oldBlockId = (block.getType().getId() << 4) | (block.getData() & 0xF);
+        return getLegacyBlock(storage, oldBlockId, x, y, z);
+    }
+
+    /**
+     *
+     * @param storage ViaVersion's block entity storage (used to fix block entity state differences)
+     * @param blockId the pre-1.13 block id
+     * @param x X coordinate of block
+     * @param y Y coordinate of block
+     * @param z Z coordinate of block
+     * @return the block state updated to the latest Minecraft version
+     */
+    public int getLegacyBlock(BlockStorage storage, int blockId, int x, int y, int z) {
+        // Convert block state from old version (1.12.2) -> 1.13 -> 1.13.1 -> 1.14 -> 1.15 -> 1.16 -> 1.16.2
+        blockId = mappingData1_12to1_13.getNewBlockId(blockId);
+        // Translate block entity differences - some information was stored in block tags and not block states
+        if (storage.isWelcome(blockId)) { // No getOrDefault method
+            BlockStorage.ReplacementData data = storage.get(new Position(x, (short) y, z));
+            if (data != null && data.getReplacement() != -1) {
+                blockId = data.getReplacement();
+            }
+        }
+        for (int i = protocolList.size() - 1; i >= 0; i--) {
+            MappingData mappingData = protocolList.get(i).getProtocol().getMappingData();
+            if (mappingData != null) {
+                blockId = mappingData.getNewBlockStateId(blockId);
+            }
+        }
+        return blockId;
+    }
+
+    @Override
+    public boolean isLegacy() {
+        return true;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/tech/skyouo/brilliant/geyser/world/dummy/FakePlugin.java b/src/main/java/tech/skyouo/brilliant/geyser/world/dummy/FakePlugin.java
new file mode 100644
index 0000000000000000000000000000000000000000..becfc61328d9313cf4a37bdef373299daeddcf4a
--- /dev/null
+++ b/src/main/java/tech/skyouo/brilliant/geyser/world/dummy/FakePlugin.java
@@ -0,0 +1,133 @@
+package tech.skyouo.brilliant.geyser.world.dummy;
+
+import org.bukkit.Bukkit;
+import org.bukkit.Server;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.configuration.file.FileConfiguration;
+import org.bukkit.generator.ChunkGenerator;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.PluginDescriptionFile;
+import org.bukkit.plugin.PluginLoader;
+import org.bukkit.plugin.java.JavaPlugin;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.File;
+import java.io.InputStream;
+import java.util.List;
+import java.util.logging.Logger;
+
+public class FakePlugin implements Plugin {
+    public boolean enable = true;
+    public String name;
+
+    public FakePlugin(String pluginName) {
+        this.name = pluginName;
+    }
+
+    @Override
+    public void onEnable() {
+
+    }
+
+    @Override
+    public boolean isNaggable() {
+        return false;
+    }
+
+    @Override
+    public void setNaggable(boolean canNag) {
+
+    }
+
+    @Override
+    public @Nullable ChunkGenerator getDefaultWorldGenerator(@NotNull String worldName, @Nullable String id) {
+        return null;
+    }
+
+    @Override
+    public @NotNull Logger getLogger() {
+        return null;
+    }
+
+    @Override
+    public @NotNull String getName() {
+        return this.name;
+    }
+
+    @Override
+    public @NotNull File getDataFolder() {
+        return null;
+    }
+
+    @Override
+    public @NotNull PluginDescriptionFile getDescription() {
+        return null;
+    }
+
+    @Override
+    public @NotNull FileConfiguration getConfig() {
+        return null;
+    }
+
+    @Override
+    public @Nullable InputStream getResource(@NotNull String filename) {
+        return null;
+    }
+
+    @Override
+    public void saveConfig() {
+
+    }
+
+    @Override
+    public void saveDefaultConfig() {
+
+    }
+
+    @Override
+    public void saveResource(@NotNull String resourcePath, boolean replace) {
+
+    }
+
+    @Override
+    public void reloadConfig() {
+
+    }
+
+    @Override
+    public @NotNull PluginLoader getPluginLoader() {
+        return null;
+    }
+
+    @Override
+    public @NotNull Server getServer() {
+        return null;
+    }
+
+    @Override
+    public boolean isEnabled() {
+        return this.enable;
+    }
+
+    @Override
+    public void onDisable() {
+
+    }
+
+    @Override
+    public void onLoad() {
+
+    }
+
+    @Override
+    public boolean onCommand(@NotNull CommandSender sender, @NotNull Command command, @NotNull String label, @NotNull String[] args) {
+        return false;
+    }
+
+    @Override
+    public @Nullable List<String> onTabComplete(@NotNull CommandSender sender, @NotNull Command command, @NotNull String alias, @NotNull String[] args) {
+        return null;
+    }
+}
